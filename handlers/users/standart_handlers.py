from typing import Union

from aiogram import types
from aiogram.dispatcher import FSMContext
from aiogram.dispatcher.filters import Command
from aiogram.dispatcher.filters.state import StatesGroup, State
from aiogram.types import CallbackQuery, Message

from keyboards.inline import menu_keyboard as menu_kb
from loader import dp
from utils.db_api.db_commands import get_subs_user, get_sub, add_subscription, del_subs, del_sub, row2dict
from utils.parser.rezka_parser import search_serial, search_by_link


class StateMenu(StatesGroup):
    home_menu = State()
    search = State()
    type = State()


@dp.callback_query_handler(menu_kb.menu_cd.filter(func="close"))
async def close_menu(call: CallbackQuery):
    await call.message.edit_text("–î–æ –≤—Å—Ç—Ä–µ—á–∏!", reply_markup=None)


@dp.message_handler(Command('menu'))
async def command_menu(message: types.Message):
    await message.answer("–ü—Ä–∏–≤–µ—Ç")
    await show_menu(message)


# –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="menu"))
async def show_menu(message: Union[CallbackQuery, Message]):
    markup = menu_kb.get_menu()
    if isinstance(message, Message):
        await message.answer('–ú–µ–Ω—é –±–æ—Ç–∞', reply_markup=markup)
    if isinstance(message, CallbackQuery):
        call = message
        await call.message.edit_text(text='–ú–µ–Ω—é –±–æ—Ç–∞:', reply_markup=markup)


# –í—Å–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤–∫–ª/–≤—ã–∫–ª
# TODO: –°–¥–µ–ª–∞—Ç—å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –∑–≤—É–∫–∞
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="notific"))
async def notification(call: CallbackQuery, callback_data: dict):
    await call.answer('–§—É–Ω–∫—Ü–∏—è –≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ')


# –í–∫–ª—é—á–∞–µ–º –ø–æ–∏—Å–∫ –ø–æ –∏–º–µ–Ω–∏ —Å–µ—Ä–∏–∞–ª–∞
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="search"))
async def enter_serial_name(call: CallbackQuery):
    text = "–í–≤–µ–¥–∏—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ —Å–µ—Ä–∏–∞–ª–∞:"
    await call.message.edit_reply_markup()
    await call.message.edit_text(text=text)
    await StateMenu.search.set()


# –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –Ω–∞–π–¥–µ–Ω–Ω—ã–µ —Å–µ—Ä–∏–∞–ª—ã –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –∫ –Ω–∏–º
# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞: –ø–æ–¥–ø–∏—Å–∫–∏/ –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫/ –º–µ–Ω—é/ –∑–∞–∫—Ä—ã—Ç—å.
@dp.message_handler(state=StateMenu.search)
async def show_search(message: Message,
                      state: FSMContext):

    # await message.answer(text="–ü–æ–∂–∞–ª—É–π—Å—Ç–∞ –ø–æ–¥–æ–∂–¥–∏—Ç–µ.")
    serial = message.text
    serials = await search_serial(name=serial) # [{link, name_serial, info}]
    markup = menu_kb.get_keyboard_serials(len(serials))
    text = "–í—ã–±–µ—Ä–∏—Ç–µ –æ–¥–∏–Ω –∏–∑ –≤–∞—Ä–∏–∞–Ω—Ç–æ–≤: \n\n"
    if not len(serials):
        text = "–ö —Å–æ–∂–∞–ª–µ–Ω–∏—é –Ω–∏—á–µ–≥–æ –Ω–µ –Ω–∞—à–ª–æ—Å—å.\n–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å –µ—â–µ?"
    for number, film in enumerate(serials):
        number += 1
        text += f"{number}. {film['name_serial']}\n{film['info']}\n\n"
        async with state.proxy() as data:
            data[number] = film
    # –ü–æ–ª—É—á–∞–µ–º –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –≥–¥–µ callback_data —ç—Ç–æ –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä
    await message.answer(text=text, reply_markup=markup)
    await state.reset_state(with_data=False)


# –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω—ã–π —Å–µ—Ä–∏–∞–ª –∏ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É —Å –≤—ã–±–æ—Ä–æ–º —Ç–∏–ø–∞ –ø–æ–¥–ø–∏—Å–∫–∏
# –ö–ª–∞–≤–∏–∞—Ç—É—Ä–∞:
# –≤—ã–±–æ—Ä –æ–∑–≤—É—á–∫–∏(1,2....n)\n
# –≤—Å–µ\n –ø–æ—Å–ª–µ–¥–Ω—è—è —Å–µ—Ä–∏—è\n –Ω–æ–≤—ã–π –ø–æ–∏—Å–∫; –º–µ–Ω—é; –∑–∞–∫—Ä—ã—Ç—å
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="select"))
async def select_type_subscribe(call: CallbackQuery,
                                state: FSMContext,
                                callback_data: dict):
    number = int(callback_data['number'])
    data = await state.get_data()
    # State –º–æ–∂–µ—Ç –ø—Ä–∏–π—Ç–∏ –∏–ª–∏ –∏–∑ –º–µ–Ω—é –∏–∑–º–µ–Ω–µ–Ω–∏—è, –∏–ª–∏ –∏–∑ —Å–æ–∑–¥–∞–Ω–∏—è –ø–æ–¥–ø–∏—Å–∫–∏

    serial = data[number] # {link, name_serial, info}
    serial = await search_by_link(serial)
    serial["user_id"] = call.from_user.id
    sub_id = data[number].get('id', None)
    if sub_id:
        serial["id"] = sub_id
    voices = serial["voices"] # [{voices_id, title, last_episode, last_season}]
    markup = menu_kb.get_keyboard_type(len(voices))
    text = f"{serial['name_serial']}\n{serial['info']}\n\n"
    text += "–í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏:\n"
    if len(voices) > 1:
        text += f"üìå 1 - {len(voices)} - –Ω–æ–≤—ã–µ —Å–µ—Ä–∏–∏ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –æ–∑–≤—É—á–∫–µ\n"
    elif len(voices) == 1:
        text += f"üìå 1 - –Ω–æ–≤—ã–µ —Å–µ—Ä–∏–∏ –≤ –≤—ã–±—Ä–∞–Ω–Ω–æ–π –æ–∑–≤—É—á–∫–µ\n"
    text += "üìå –í—Å–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è - –ª—é–±—ã–µ –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Å–µ—Ä–∏–∞–ª—É\n\n"
            # "üìå –ü–æ—Å–ª–µ–¥–Ω—è—è —Å–µ—Ä–∏—è - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –ø—Ä–∏ –ª—é–±—ã—Ö " \
            # "–∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö –Ω–∞ —Å–∞–π—Ç–µ –≤ –ø–æ—Å–ª–µ–¥–Ω–µ–π –≤—ã—à–µ–¥—à–µ–π —Å–µ—Ä–∏–∏ " \
            # "–ö–∞–∫ —Ç–æ–ª—å–∫–æ –≤—ã–π–¥–µ—Ç –Ω–æ–≤–∞—è —Å–µ—Ä–∏—è, —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –±—É–¥—É—Ç –ø—Ä–∏—Ö–æ–¥–∏—Ç—å –ø–æ –Ω–µ–π, –∏ —Ç.–¥.. \n\n"
    if voices:
        text += "–í—ã–±–æ—Ä –ø–æ –æ–∑–≤—É—á–∫–µ:\n"
        for num, voice in enumerate(voices):
            num += 1
            text += f"{num}. {voice['title']}\n"

    await StateMenu.type.set()
    # –ö–ª–∞–¥—ë–º –≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π State –≤—Å–µ –¥–∞–Ω–Ω—ã–µ –ø–æ –Ω–∞—à–µ–º—É —Å–µ—Ä–∏–∞–ª—É:
    # –ö—Ä–æ–º–µ type
    # {user_id, serial_name, info, voices, link}
    state = dp.get_current().current_state()
    async with state.proxy() as data:
        data['subscription'] = serial
    await state.reset_state(with_data=False)
    await call.message.edit_text(text=text, reply_markup=markup)


# —Å—é–¥–∞ –ø—Ä–∏–ª–µ—Ç–∞–µ—Ç –≤—Å—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Ç –Ω–∞–∂–∞—Ç–∏–π –Ω–∞ type
# –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –≤–æ–∞—Ä–∏–∞–Ω—Ç—ã –æ–∑–≤—É—á–µ–∫ –¥–∞–Ω–Ω–æ–≥–æ —Å–µ—Ä–∏–∞–ª–∞ .
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="type"))
async def set_type_subscription(call: CallbackQuery,
                                callback_data: dict):
    # TODO: –æ—Ç—Ä–∞–±–æ—Ç–∞—Ç—å –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    await StateMenu.type.set()
    state = dp.get_current().current_state()
    data = await state.get_data()
    serial = data["subscription"]
    serial["type"] = int(callback_data["cd_type"])
    num = int(callback_data["number"]) - 1
    voices = serial.pop("voices", None)
    if serial["type"] == 1:
        serial["voice_name"] = voices[num]['title']
        serial["voice_id"] = voices[num]['voice_id']
        serial["last_season"] = voices[num]['last_season']
        serial["last_episode"] = voices[num]['last_episode']
    add_subscription(serial)
    await state.finish()
    await call.answer(text="–ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–∞.", show_alert=True)
    await show_menu(call)


# –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä–æ–π
# –≤ –∫–ª–∞–≤–∏–∞—Ç—É—Ä—É –∑–∞—à–∏–ª–∏ id –ø–æ–¥–ø–∏—Å–æ–∫
# –ü–æ–¥–ø–∏—Å–∫–∏ 1,2,....n/ —É–¥–∞–ª–∏—Ç—å –≤—Å–µ –ø–æ–¥–ø–∏—Å–∫–∏/ –º–µ–Ω—é, –∑–∞–∫—Ä—ã—Ç—å.
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="show_subs"))
async def show_subs(call: CallbackQuery):
    subs = get_subs_user(call.from_user.id)
    # –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –ø–æ–∫–∞–∑–∞—Ç—å –ò–º—è/ info / —Ç–∏–ø/
    # –ï—Å–ª–∏ –≤—Å–µ, —Ç–æ –±–æ–ª—å—à–µ –Ω–∏—á–µ–≥–æ.
    # –ï—Å–ª–∏ –ø–æ –æ–∑–≤, —Ç–æ —Ç–æ–ª—å–∫–æ –æ–∑–≤—É—á–∫—É,
    # –ï—Å–ª–∏ –ø–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ—Ä–∏–∏, —Ç–æ –ø–æ—Å–ª–µ–¥–Ω—é—é —Å–µ—Ä–∏—é.
    text = "–í–∞—à–∏ –ø–æ–¥–ø–∏—Å–∫–∏:\n\n" if len(subs) else "–£ –≤–∞—Å –ø–æ–∫–∞ –µ—â–µ –Ω–µ—Ç –ø–æ–¥–ø–∏—Å–æ–∫"
    sub_type = {0: "–í—Å–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è", 1: "–ü–æ –æ–∑–≤—É—á–∫–µ", 2: "–ü–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ—Ä–∏–∏"}
    for num, sub in enumerate(subs):
        num += 1
        if sub["type"] == 0:
            text += f"{num}. {sub['name_serial']}\n{sub['info']}\n–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {sub_type[sub['type']]}\n\n"
        elif sub["type"] == 1:
            text += f"{num}. {sub['name_serial']}\n{sub['info']}\n–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {sub_type[sub['type']]}\n" \
                    f"{sub['voice_name']}\n\n"
        elif sub["type"] == 2:
            text += f"{num}. {sub['name_serial']}\n{sub['info']}\n–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {sub_type[sub['type']]}\n" \
                    f"–°–µ–∑–æ–Ω {sub['last_season']}, —Å–µ—Ä–∏—è {sub['last_episode']}\n\n"
    markup = menu_kb.get_keyboard_subs(subs)

    await call.message.edit_text(text=text, reply_markup=markup)


# –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥–ø–∏—Å–∫—É
# –ò–∑–º–µ–Ω–∏—Ç—å, –£–¥–∞–ª–∏—Ç—å/ –Ω–∞–∑–∞–¥, –º–µ–Ω—é, –∑–∞–∫—Ä—ã—Ç—å
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="show_sub"))
async def show_sub(call: CallbackQuery, callback_data: dict):
    sub_id = int(callback_data["sub_id"])
    sub = row2dict(get_sub(sub_id))
    text = ""
    sub_type = {0: "–í—Å–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è", 1: "–ü–æ –æ–∑–≤—É—á–∫–µ", 2: "–ü–æ –ø–æ—Å–ª–µ–¥–Ω–µ–π —Å–µ—Ä–∏–∏"}
    if sub["type"] == 0:
        text += f"{sub['name_serial']}\n{sub['info']}\n–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {sub_type[sub['type']]}\n\n"
    elif sub["type"] == 1:
        text += f"{sub['name_serial']}\n{sub['info']}\n–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {sub_type[sub['type']]}\n" \
                f"{sub['voice_name']}\n\n"
    elif sub["type"] == 2:
        text += f"{sub['name_serial']}\n{sub['info']}\n–¢–∏–ø –ø–æ–¥–ø–∏—Å–∫–∏: {sub_type[sub['type']]}\n" \
                f"–°–µ–∑–æ–Ω {sub['season']}, —Å–µ—Ä–∏—è {sub['episode']}\n\n"
    markup = menu_kb.get_keyboard_sub(sub_id)
    await call.message.edit_text(text=text, reply_markup=markup)
    # –ö–ª–∞–¥—ë–º –≤ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω—ã–π State –ø–æ–¥–ø–∏—Å–∫—É:
    await StateMenu.search.set()
    state = dp.get_current().current_state()
    async with state.proxy() as data:
        data[0] = sub
    await state.reset_state(with_data=False)


# –£–¥–∞–ª–∏—Ç—å –≤—Å—ë
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="del_all"))
async def delete_all_subs(call: CallbackQuery):
    user_id = call.from_user.id
    del_subs(user_id)
    await show_menu(call)


# –£–¥–∞–ª–∏—Ç—å –ø–æ–¥–ø–∏—Å–∫—É
@dp.callback_query_handler(menu_kb.menu_cd.filter(func="del_one"))
async def delete_one_sub(call: CallbackQuery, callback_data: dict):
    await del_sub(int(callback_data["sub_id"]))
    await show_subs(call)
